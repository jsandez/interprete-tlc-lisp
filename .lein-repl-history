(partition 2 '(a 1 b 2 c 3 d 4)
)
(apply zipmap (apply map list (partition 2 '(a 1 b 2 c 3 d 4))))
(apply zipmap (apply map list (
partition 2 '(a 1 b 2 c 3 d 4))))
{:v2 B, :v1 a, :v3 c} 
({:v2 B, :v1 a, :v3 c} )
{:v2 B, :v1 a, :v3 c}
({:v2 B, :v1 a, :v3 c} :v2)
({:v2 'B, :v1 'a, :v3 'c} :v2)
(list {:v2 'B, :v1 'a, :v3 'c})
(apply hash-map '(a 1 b 2 c 3 d 4 e 5))
(seq {a 1, e 5, c 3, b 2, d 4})
(list {a 1, e 5, c 3, b 2, d 4})
(list {:v2 'B, :v1 'a, :v3 'c})
(apply list {:v2 'B, :v1 'a, :v3 'c})
(apply map list {:v2 'B, :v1 'a, :v3 'c})
(apply list {:v2 'B, :v1 'a, :v3 'c})
(flatten (apply list {:v2 'B, :v1 'a, :v3 'c}))
((apply hash-map amb) '(a 1 b 2 c 3) )
(apply hash-map '(a 1 b 2 c 3) )
(assoc {a 1, c 3, b 2} 'd 4)
(assoc '{a 1, c 3, b 2} 'd 4)
(flatten (apply list (assoc '{a 1, c 3, b 2} 'd 4)))
(assoc '{a 1, c 3, b 2} 'd 4)
p-formales.core=> 
(assoc '{a 1, c 3, b 2} 'd 4))
(assoc '{a 1, c 3, b 2} 'd 4)
(apply hash-map '(a 1 b 2 c 3) )
(vec '(a 1 b 2 c 3 d 4 e 5))
(partition 2 (vec '(a 1 b 2 c 3 d 4 e 5)))
(apply vec '((1 a) (2 b) (3 c)))
(apply map vec '((1 a) (2 b) (3 c)))
(vec '(1 a)
)
(vec '1 '2 '3 '4)
(partition 2 '(a 1 b 2 c 3 d 4 e 5))
(map hash-map (partition 2 '(a 1 b 2 c 3 d 4 e 5)))
(into #{} (partition 2 '(a 1 b 2 c 3 d 4 e 5)))
(into {} (partition 2 '(a 1 b 2 c 3 d 4 e 5)))
(into {} (map vec (partition 2 '(a 1 b 2 c 3 d 4 e 5))))
(into {} (partition 2 '(a 1 b 2 c 3 d 4 e 5)))))
(into {} (partition 2 '(a 1 b 2 c 3 d 4 e 5)))
(into {} (map vec (partition 2 '(a 1 b 2 c 3 d 4 e 5))))
(map vec (partition 2 '(a 1 b 2 c 3 d 4 e 5)))
(prn)
(do (prn "hola") (prn) "hola)
)
;
(do (prn "hola"))
(do (prn "hola") (prn))
(do (prn "hola") (prn) "hola")
({:a 1 :b 2} :a)
({:a 1 :b 2} :c)
(concat '(1 2) '(3))
(concat '(1 2) nil)
(concat '(1 2) ())
(concat () ())
(concat nil nil)
(if (list? 'A))
(if (list? 'A) a)
(if (list? 'A) 'a)
(if (list? 'A) a)(ni
)
(nil? ())
(empty? ())
(list *error*=
)
(list *error*)
(list '*error*)
(list '*error*
)=
(== 1 2)
(cons 'a 'b)
(not= 1 2)
(apply and (true true)
)
(apply and (true true)
)
(apply #(and %1 %2)  (true true))
(apply #(and %1 %2)  '(true true))
(list? nil=
)
(list? nil)
(concat () ()) 
(concat nil nil)
(cons 3 ())
(def aasd (123))
(def asd '(123))
asd
(list '90 asd)
(def asd 123)
asd
(list '90 asd)
(seq nil)
(list? nil=
)
(list? nil)=
(list? nil)
(coll? nil)
(concat nil nil)
(concat () ()))
(concat () ())
(nil? ())
(defn controlar-aridad [l n]
  (cond
    (== (count l) n) n
    :else (cons '*error* (if (< (count l) n) '(too-few-args) '(too-many-args)))))
(controlar-aridad '((1 2))  2)
(= (controlar-aridad '((1 2))  2) '(*error* too-few-args))
(count '((1 2)))
(read-line)
(read)
(with-out-str ("hola))
)
asd
adf
)))Ã§asd
f
asdf9asdf
sf
SA))
(read)
(read-line)
(defn hola[x] (let [a (readline)] (if (== a 1) a nil)))
(defn hola[x] (let [a (read)] (if (== a 1) a nil)))
hola
(hola)
(defn hola[] (let [a (read)] (if (== a 1) a nil)))
(hola)
(defn igual? [a b]
  (letfn [(notEmptyList?[x] (and (list? x) (not (empty? x))))
          (null?[x] (or (nil? x) (= 'NIL x) (= (concat) x)))]
    (cond
      ;; numeros
      (and (number? a) (number? b)) (== a b)
      ;; strings
      (and (string? a) (string? b)) (= a b)
      ;; simbolos
      (and (symbol? a) (symbol? b)) (= (map char (clojure.string/lower-case (str a)))
                                       (map char (clojure.string/lower-case (str b))))
      ;; listas no vacias
      (and (notEmptyList? a) (notEmptyList? b)) (and 
                                                 (== (count a) (count b)) 
                                                 (reduce #(and %1 %2) (map igual? a b)))
      ;; nulos
      (and (null? a) (null? b)) true
      :else false)))
(fnc-read)
(fnc-read a)
(fnc-read 'a)
(igual? () nil)
quit
(fnc-read 'a)
(fnc-read 1)
(fnc-read)
(fnc-read ())
(fnc-read)
(fnc-read ())
quit
(fnc-read ())
(fnc-read '(1 2))
quit
(fnc-read ())
(fnc-read "a")
(fnc-read ())
()
(symbol a)
(quote a)
(quote "asd")
(doseq [ln (line-seq (java.io.BufferedReader. *in*))]
   (println ln))
(doseq [line (line-seq (java.io.BufferedReader. *in*))] (str line))
(with-in-str "hola" (println (read))
)
(with-in-str "hola" (println (read))
)
(with-in-str "hola" (println (read)))
(with-in-str "hola" (print (read)))
(with-in-str "hola" (symbol (read)))
(symbol "1")
(print ("asdf\nwe"))
(print ("asdf\\nwe"))
(print ("asdf"))
(print "asdf\ndf")
(print "\nnil")
(println "\nil")
(println "asd")
(println "")
(print "")
(print "\n")
quit
(fnc-terpri ())
(fnc-terpri '(1))
(with-out-str (print "asd"))
(= "asd" (with-out-str (print "asd")))
(= "asd" (with-out-str (print "asd1")))
(println)
(print "")
(fnc-terpri ())
(fnc-terpri '(1))
(fnc-terpri '(1 2))
(print)
(print "\nnil")
quit
(fnc-terpri ())
(print "nil" (println))
(print "\nnil")
(println "\nnil")
((reduce #(and %1 %2) (map number? l)) ())
(reduce #(and %1 %2) (map number? ()))
(reduce #(and %1 %2) (map number? '(1 2)))
(reduce #(and %1 %2) (map number? '(1 2 A)))
(reduce #(and %1 %2) (map number? '(1 2)))
(defn checkNotNumber[l] (filter (fn [x] (not (number?))) l))
(checkNotNumber '(1 2 3))
(checkNotNumber (1 2 3))
(defn (notNumber[l] (filter (fn [x] (not (number?)))) l))
(defn (notNumber[l] (filter (fn [x] (not (number?))) l)))
(defn notNumber[l] (filter (fn [x] (not (number?))) l))
(notNumber (1 2 3))
(defn notNumber[l] (filter (fn [x] (not (number? x)))) l)
(notNumber (1 2 3))
(filter number? '(1 2 3))
(notNumber '(1 2 3))
(filter number? (1 2 3))
(filter symbol? (1 2 3))
(filter number? (1 2 3))
(filter number? (list 1 2 3))
(filter number? (list a b c))
(filter number? (list A))
(filter number? (list 'A))
(filter number? (list a b c))
(filter number? (list 1 2 3))
(filter number? '(1 2 3))
(filter number? '(a b c))
(filter (fn[x] (not (number? x)) '(a b c))
)
(filter (fn[x] (not (number? x)) '(a b c)))
(filter (fn[x] (not (number? x))) '(a b c))
(defn notNumber[l] (filter (fn[x] (not (number? x))) l))
(notNumber (1 2 3))
(notNumber (a b c))
(notNumber '(1 2 3))
(notNumber '(a b c))
(nil? ())
(apply + (1 2 3 4))
(apply + '(1 2 3 4))
(apply - '(1 2 3 4))
(apply - '(3))
(apply < '(1 2))
(reverse '((1 2 3)))
(list? '1)
(list? 'a)
(list? "<sdf")
(reverse (first '((1 2 3)))
)
(reverse (first '(1 2 3))
(reverse (first '(1 2 3)))
)
({a 1, b 2, c 3} a)
(({a 1, b 2, c 3}) a)
({a 1, b 2, c 3} 'a)
({:a 1, :b 2, :c 3} :a)
({a 1, b 2, c 3} a)
({a 1, b 2, c 3} 0a)
({a 1, b 2, c 3} 'a)
((hash-map a 1, b 2, c 3))
((hash-map 'a 1, 'b 2, 'c 3))
(hash-map 'a 1, 'b 2, 'c 3)
((hash-map 'a 1, 'b 2, 'c 3) 'a)
(type '(1 2 3))
(type (flatten '(1 2 3)))
(cons 'a '(1 2 3))
(type (cons 'a '(1 2 3)))
(type (into () '(1 2 3)))
(apply list '(1 2 3))
(type (apply list '(1 2 3)))
(get a (hash-map 'a 1, 'b 2, 'c 3))
(get 'aa (hash-map 'a 1, 'b 2, 'c 3))
(get 'a (hash-map 'a 1, 'b 2, 'c 3))
(get 1 (hash-map 'a 1, 'b 2, 'c 3))
(get 'A (hash-map 'a 1, 'b 2, 'c 3))
(apply list {a 1, c 3, b 2})
(apply list {'a 1, 'c 3, 'b 2})
(flatten (apply list {'a 1, 'c 3, 'b 2}))
(type (flatten (apply list {'a 1, 'c 3, 'b 2})))
(into () (flatten (apply list {'a 1, 'c 3, 'b 2})))
(type (into () (flatten (apply list {'a 1, 'c 3, 'b 2}))))
(list '(1 2 3))
(apply list {'a 1, 'c 3, 'b 2}
)
(apply list {'a 1, 'c 3, 'b 2})
(apply vals {'a 1, 'c 3, 'b 2})
(keys {'a 1, 'c 3, 'b 2})
(str 'a)
(symbol (str 'a))
(symbol (clojure.string/lower-case(str 'A)))
(symbol? 32)
(symbol (clojure.string/lower-case(str '1)))
(symbol (clojure.string/lower-case(str '234)))
(keys {'a 1, 'c 3, 'b 2})(keys {'a 1, 'c 3, 'b 2})
(get {'a 1, 'c 3, 'b 2} 'z)
(list (list '*error 'unbound-symbol key) '(1 2 3))
(list (list '*error 'unbound-symbol 'key) '(1 2 3))
(str "asd" 'n)
(type '((*error* unbound-symbol n) (v 1 w 3 x 6)))
(type '((type (*error* unbound-symbol n)) (v 1 w 3 x 6)))
(type '(x))
(map type '(de f (x)))
(map type '(de f (x) +))
(nth 2 '(1 2 3))
(nth '(1 2 3) 2)
(nth '(1 2 3) 5)
(nth '(1 2 3) 4)
(get 4 '(1 2 3))
(get 2 '(1 2 3))
(second (second '(1 2))
)
(second (second '(1 2)))
(second (second '(1 2 3)))
(second (second (1 2 3)))
(second '(1 2 3))
(second (rest '(1 2 3)))
(second (rest '(1 2)))
(symbol? nil)
(def a '(+ x 1))
a
(a 1)
a
(a)
(a) a
((a) a)
((a) 1)
(defn h[] a)
j
h
(h)
(a)
(type a)
(resolve a)
(resolve (first a))
((resolve (first a)) (second a) (rest (second a)))
(resolve (first a) (second a) (rest (second a)))
(resolve (first a))
((resolve (first a)) 1 2)
((resolve (first a)) 1 (rest (second a)))
a
((resolve (first a)) 1 (second (rest a)))
(second (rest '(1))
)
(second (rest '(1)))
(list? nil)
(symbol? nil)
(list 'a (list 1 2 3))
(apply list '(1 2 3) 4)
(apply list '(1 2 3) '4)
(apply list '(1 2 3))
(apply list '(1 2 3 (4 5))
)
(take 4 '(1 2 3))
(drop 4 '(1 2 3))
(flatten '(() 1 (1 2 3)))
(cons 1 '(1 2 3))
(into () (cons 1 '(1 2 3)))
(apply list (cons 1 '(1 2 3)))
(type (cons 1 '(1 2 3)))
(type (apply list (cons 1 '(1 2 3))))
(false? nil)
(amb-to-map '(nil nil t t v 1 w 3 x 6))
(into {} (map vec (partition 2 '(nil nil t t v 1 w 3 x 6))
)
(into {} (map vec (partition 2 '(nil nil t t v 1 w 3 x 6))))
(get (into {} (map vec (partition 2 '(nil nil t t v 1 w 3 x 6)))) nil)
(second (second '(if t))
)
(second (second '(if t)))
(second (second (list 'if 't)))
'if
(list 'if 't)
(second (rest (list 'if 't)))
quit
(defn asd[x _] (+ 1 x))
(asd 3)
(asd 3 234)
(if nil=)
(if nil)
asdf
quit
(aplicar asdf)
(aplicar 't)
(igual? true true)
(igual? 'true 'true)
(igual? 1 1 )
(== true true)
(= true true)
(= "true" "true")
(= '(1 2 3) '(1 2 3))
(= '(1 2 3) '(1 2 3 4))
(= '(1 2 A) '(1 2 a))
(symbol 1)
(list? ())
((list '())
)
(list? '())
(false? nil)
(if () 1 2)
(if nil 1 2)
(if false 1 2)
(if nil 1 2)
(if 't 1 2)
(butlast ())
(last '(1))
(take 3 '(1 2 3))
(take-last 3 '(1 2 3))
(take-last 1 '(1 2 3))
(drop 3 '(1 2 3))
(drop 4 '(1 2 3))
(partition 3 '(1 2 3 4))
(butlast '(1 2 3 4))
(nth 4 '(1 2 3 4))
(nth '(1 2 3) 4)
(butlast (rest '(1 2 3 4))
)
(butlast (rest '(if nil 9))
)
(rest (rest '(if (gt 0 2) a (setq m 8))))
(butlast (rest (rest (rest '(if (gt 0 2) a (setq m 8))))))
(butlast (rest (rest '(if (gt 0 2) a (setq m 8)))))
(butlast (rest (rest '(if (gt 0 2) a))))
(take-nth 4 '(1 2 3))
(take-nth 3 '(1 2 3))
(take-nth 2 '(1 2 3))
(drop 4 '(1 2 3))
(butlast '(1 2 3))
(last '(1 2 3))
(reverse (second '(1 2 3 4 5 4)))
(second (reverse '(1 2 3 4 5 4)))
(first (rest (rest '(1 2 3))
)
(first (rest (rest '(1 2 )))
)
(first ())
(first (first '(1))
)
(second '(1 2))
(second '(1))
(drop 2 '(1 2))
(drop 2 '(1 2 3 4 ))
(list nil nil)
(controlar-aridad () 0)
(drop 3 '(1 2 3 4 ))
(drop 3 '(1 2))
(filter some? '(nil nil))
(symbol? nil=
)
(symbol? nil)
(println nil)
(into {} (map vec (partition 2 '(1 2 3 4)))
)
(into {} (map vec (partition 2 '(1 2 3 4))))
(into {} (map vec (partition 2 '(1 2 3))))
(partition 2 '(1 2 3))
(nil? ())
(some? ())
(first ())
(partition 2 '(1))
(partition 2 nil)
(partition 2 2)
(partition 2 '(1 2 3))
('hola)
(rest '(hola))
(odd (count ())
)
(odd? (count ()))
(odd? (count (1)))
(odd? (count '(1)))
(rest ((1)))
(rest ('(1)))
(rest '((1)))
(rest '((1 2)))
(partition 2 '(1 2 3 4))
(first '+)
(not (seq? '+)) 
(cons '(1 2 3) '(4 5 6))
(next '(1 2 3))
(odd? (count '(x 7 y))
)
(first '())
(second '())
(rest (second '())
)
(rest (second '()))
(rest (rest '(1 2 3 4 5))
)
(rest (rest '(1 2 3 4 5)))
(rest (rest '(1 2 3 4)))
(rest (rest '(1 2 3)))
(rest (rest '(1 2)))
quit
