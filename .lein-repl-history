(notNumber '(a b c))
(nil? ())
(apply + (1 2 3 4))
(apply + '(1 2 3 4))
(apply - '(1 2 3 4))
(apply - '(3))
(apply < '(1 2))
(reverse '((1 2 3)))
(list? '1)
(list? 'a)
(list? "<sdf")
(reverse (first '((1 2 3)))
)
(reverse (first '(1 2 3))
(reverse (first '(1 2 3)))
)
({a 1, b 2, c 3} a)
(({a 1, b 2, c 3}) a)
({a 1, b 2, c 3} 'a)
({:a 1, :b 2, :c 3} :a)
({a 1, b 2, c 3} a)
({a 1, b 2, c 3} 0a)
({a 1, b 2, c 3} 'a)
((hash-map a 1, b 2, c 3))
((hash-map 'a 1, 'b 2, 'c 3))
(hash-map 'a 1, 'b 2, 'c 3)
((hash-map 'a 1, 'b 2, 'c 3) 'a)
(type '(1 2 3))
(type (flatten '(1 2 3)))
(cons 'a '(1 2 3))
(type (cons 'a '(1 2 3)))
(type (into () '(1 2 3)))
(apply list '(1 2 3))
(type (apply list '(1 2 3)))
(get a (hash-map 'a 1, 'b 2, 'c 3))
(get 'aa (hash-map 'a 1, 'b 2, 'c 3))
(get 'a (hash-map 'a 1, 'b 2, 'c 3))
(get 1 (hash-map 'a 1, 'b 2, 'c 3))
(get 'A (hash-map 'a 1, 'b 2, 'c 3))
(apply list {a 1, c 3, b 2})
(apply list {'a 1, 'c 3, 'b 2})
(flatten (apply list {'a 1, 'c 3, 'b 2}))
(type (flatten (apply list {'a 1, 'c 3, 'b 2})))
(into () (flatten (apply list {'a 1, 'c 3, 'b 2})))
(type (into () (flatten (apply list {'a 1, 'c 3, 'b 2}))))
(list '(1 2 3))
(apply list {'a 1, 'c 3, 'b 2}
)
(apply list {'a 1, 'c 3, 'b 2})
(apply vals {'a 1, 'c 3, 'b 2})
(keys {'a 1, 'c 3, 'b 2})
(str 'a)
(symbol (str 'a))
(symbol (clojure.string/lower-case(str 'A)))
(symbol? 32)
(symbol (clojure.string/lower-case(str '1)))
(symbol (clojure.string/lower-case(str '234)))
(keys {'a 1, 'c 3, 'b 2})(keys {'a 1, 'c 3, 'b 2})
(get {'a 1, 'c 3, 'b 2} 'z)
(list (list '*error 'unbound-symbol key) '(1 2 3))
(list (list '*error 'unbound-symbol 'key) '(1 2 3))
(str "asd" 'n)
(type '((*error* unbound-symbol n) (v 1 w 3 x 6)))
(type '((type (*error* unbound-symbol n)) (v 1 w 3 x 6)))
(type '(x))
(map type '(de f (x)))
(map type '(de f (x) +))
(nth 2 '(1 2 3))
(nth '(1 2 3) 2)
(nth '(1 2 3) 5)
(nth '(1 2 3) 4)
(get 4 '(1 2 3))
(get 2 '(1 2 3))
(second (second '(1 2))
)
(second (second '(1 2)))
(second (second '(1 2 3)))
(second (second (1 2 3)))
(second '(1 2 3))
(second (rest '(1 2 3)))
(second (rest '(1 2)))
(symbol? nil)
(def a '(+ x 1))
a
(a 1)
a
(a)
(a) a
((a) a)
((a) 1)
(defn h[] a)
j
h
(h)
(a)
(type a)
(resolve a)
(resolve (first a))
((resolve (first a)) (second a) (rest (second a)))
(resolve (first a) (second a) (rest (second a)))
(resolve (first a))
((resolve (first a)) 1 2)
((resolve (first a)) 1 (rest (second a)))
a
((resolve (first a)) 1 (second (rest a)))
(second (rest '(1))
)
(second (rest '(1)))
(list? nil)
(symbol? nil)
(list 'a (list 1 2 3))
(apply list '(1 2 3) 4)
(apply list '(1 2 3) '4)
(apply list '(1 2 3))
(apply list '(1 2 3 (4 5))
)
(take 4 '(1 2 3))
(drop 4 '(1 2 3))
(flatten '(() 1 (1 2 3)))
(cons 1 '(1 2 3))
(into () (cons 1 '(1 2 3)))
(apply list (cons 1 '(1 2 3)))
(type (cons 1 '(1 2 3)))
(type (apply list (cons 1 '(1 2 3))))
(false? nil)
(amb-to-map '(nil nil t t v 1 w 3 x 6))
(into {} (map vec (partition 2 '(nil nil t t v 1 w 3 x 6))
)
(into {} (map vec (partition 2 '(nil nil t t v 1 w 3 x 6))))
(get (into {} (map vec (partition 2 '(nil nil t t v 1 w 3 x 6)))) nil)
(second (second '(if t))
)
(second (second '(if t)))
(second (second (list 'if 't)))
'if
(list 'if 't)
(second (rest (list 'if 't)))
quit
(defn asd[x _] (+ 1 x))
(asd 3)
(asd 3 234)
(if nil=)
(if nil)
asdf
quit
(aplicar asdf)
(aplicar 't)
(igual? true true)
(igual? 'true 'true)
(igual? 1 1 )
(== true true)
(= true true)
(= "true" "true")
(= '(1 2 3) '(1 2 3))
(= '(1 2 3) '(1 2 3 4))
(= '(1 2 A) '(1 2 a))
(symbol 1)
(list? ())
((list '())
)
(list? '())
(false? nil)
(if () 1 2)
(if nil 1 2)
(if false 1 2)
(if nil 1 2)
(if 't 1 2)
(butlast ())
(last '(1))
(take 3 '(1 2 3))
(take-last 3 '(1 2 3))
(take-last 1 '(1 2 3))
(drop 3 '(1 2 3))
(drop 4 '(1 2 3))
(partition 3 '(1 2 3 4))
(butlast '(1 2 3 4))
(nth 4 '(1 2 3 4))
(nth '(1 2 3) 4)
(butlast (rest '(1 2 3 4))
)
(butlast (rest '(if nil 9))
)
(rest (rest '(if (gt 0 2) a (setq m 8))))
(butlast (rest (rest (rest '(if (gt 0 2) a (setq m 8))))))
(butlast (rest (rest '(if (gt 0 2) a (setq m 8)))))
(butlast (rest (rest '(if (gt 0 2) a))))
(take-nth 4 '(1 2 3))
(take-nth 3 '(1 2 3))
(take-nth 2 '(1 2 3))
(drop 4 '(1 2 3))
(butlast '(1 2 3))
(last '(1 2 3))
(reverse (second '(1 2 3 4 5 4)))
(second (reverse '(1 2 3 4 5 4)))
(first (rest (rest '(1 2 3))
)
(first (rest (rest '(1 2 )))
)
(first ())
(first (first '(1))
)
(second '(1 2))
(second '(1))
(drop 2 '(1 2))
(drop 2 '(1 2 3 4 ))
(list nil nil)
(controlar-aridad () 0)
(drop 3 '(1 2 3 4 ))
(drop 3 '(1 2))
(filter some? '(nil nil))
(symbol? nil=
)
(symbol? nil)
(println nil)
(into {} (map vec (partition 2 '(1 2 3 4)))
)
(into {} (map vec (partition 2 '(1 2 3 4))))
(into {} (map vec (partition 2 '(1 2 3))))
(partition 2 '(1 2 3))
(nil? ())
(some? ())
(first ())
(partition 2 '(1))
(partition 2 nil)
(partition 2 2)
(partition 2 '(1 2 3))
('hola)
(rest '(hola))
(odd (count ())
)
(odd? (count ()))
(odd? (count (1)))
(odd? (count '(1)))
(rest ((1)))
(rest ('(1)))
(rest '((1)))
(rest '((1 2)))
(partition 2 '(1 2 3 4))
(first '+)
(not (seq? '+)) 
(cons '(1 2 3) '(4 5 6))
(next '(1 2 3))
(odd? (count '(x 7 y))
)
(first '())
(second '())
(rest (second '())
)
(rest (second '()))
(rest (rest '(1 2 3 4 5))
)
(rest (rest '(1 2 3 4 5)))
(rest (rest '(1 2 3 4)))
(rest (rest '(1 2 3)))
(rest (rest '(1 2)))
quit
(concat '(1) '(1 2 3))
(concat '(1) '(1 (1 2 3)))
(type (concat '(1) '(1 (1 2 3))))
(apply list (type (concat '(1) '(1 (1 2 3)))))
(apply list (concat '(1) '(1 (1 2 3))))
(evaluar-de '(de f (x)) '(x 1))
exit
(evaluar-de '(de f (x)) '(x 1))
(evaluar-de '(de f (x y) (prin3 x) (terpri) y) '(x 1))
(fnc-env ())
(fnc-env)
(fnc-env '())
evaluar-de '(de f (x y) (prin3 x) (terpri) y) '(x 1)
(evaluar-de '(de f (x y) (prin3 x) (terpri) y) '(x 1))
(map (fn[x] (x)) {x 1, y 2, z '(1 2 3)})
(map (fn[x] (x)) {'x 1, 'y 2, 'z '(1 2 3)})
(map (fn[x] ('(1)) {'x 1, 'y 2, 'z '(1 2 3)})
)
(map (fn[x] (x) {'x 1, 'y 2, 'z '(1 2 3)})
)
(into [] {'x 1, 'y 2, 'z '(1 2 3)})
(into () {'x 1, 'y 2, 'z '(1 2 3)})
(map (fn[x y] (x y) {'x 1, 'y 2, 'z '(1 2 3)})
(map (fn[x y] (x y) {'x 1, 'y 2, 'z '(1 2 3)}))
)
(map (fn[x y] (x y) {'x 1, 'y 2, 'z '(1 2 3)}))
(map (fn[[x y]] (x y) {'x 1, 'y 2, 'z '(1 2 3)}))
(map (fn[x y] (x y)) {'x 1, 'y 2, 'z '(1 2 3)})
(map (fn[[x y]] (x y)) {'x 1, 'y 2, 'z '(1 2 3)})
(map (fn[[x y]] (list x y)) {'x 1, 'y 2, 'z '(1 2 3)})
(apply list ((x 1) (y 2) (z (1 2 3))))
(apply list '((x 1) (y 2) (z (1 2 3))))
(apply list '((x 1) (y 2) (z (1 2 3)))
)
(flatten '((x 1) (y 2) (z (1 2 3))))
(apply concat '((x 1) (y 2) (z (1 2 3))))
(exit)
(x y) (+ x y)
(symbol '((x y) (+ x y)))
(str 1)
(str '1)
(list? (concat '(1) '(2))
)
(seq? (concat '(1) '(2))
)
(cons '(1 2 3) nil)
(cons '(1 2 3) '(1 2 3))
(rest (first '(1)
)
(rest (first '(1)))
))
(rest (first '(1)))
(rest (first (1)))
(rest (first '((1) 2)))
(symbol '(1 2 3))
(symbol '(a b c 1))
(apply symbol '(a b c 1))
(map symbol '(a b c 1))
(type '(1 2 3))
(list 'a 'b nil)
(apply list nil)
(list '1 ())
(type (rest (rest 1))
)
(type (rest (rest '(1))))
(apply list (type (rest (rest '(1)))))
(apply list (rest (rest '(1))))
(body-lower-case ())
(symbol (clojure.string/lower-case (str '+))
)
(sym(= (symbol (clojure.string/lower-case (str '+))) '+)
)
(= (symbol (clojure.string/lower-case (str '+))) '+)
(= (symbol (clojure.string/lower-case (str 1))) 1)
(== (symbol (clojure.string/lower-case (str 1))) 1)
(= (symbol (clojure.string/lower-case (str 1))) 1)
(cons 1 '(1 2 3))
(= (symbol (clojure.string/lower-case (str 1))) 1)(
)
(cons 1 nil)
(apply list (cons 1 nil))
exit
(body-to-lowercase '(1 2))
(body-to-lowercase 1)
(seq? (list 1 2 3))
(clojure.string/lower-case (str '1234asd))
exit
(clojure.string/lower-case (str '1234asd))
(clojure.string/lower-case (str '+))
(clojure.string/lower-case '1234123)
(clojure.string/lower-case 'we23zsedWER)
(= (clojure.string/lower-case 'we23zsedWER) (clojure.string/lower-case 'we23ZSEDWER)
)
(= (clojure.string/lower-case 'we23zsedWER) (clojure.string/lower-case 'we23ZSEDWER))
(clojure.string/lower-case (str '*Error))
(= (clojure.string/lower-case (str '*Error) (clojure.string/lower-case (str '*error))))
(= (clojure.string/lower-case (str '*Error)) (clojure.string/lower-case (str '*error))))
(= (clojure.string/lower-case (str '*Error)) (clojure.string/lower-case (str '*error)))
(symbol? '*ERror)
(symbol? nil)
(symbol? ())
(symbol? '())
(symbol? 'NIL)
(empty? ())
(symbol? nil)
(defn asd[x] (if (symbol? a) (symbol (clojure.string/lower-case (str a))) a))
(defn asd[a] (if (symbol? a) (symbol (clojure.string/lower-case (str a))) a))
(asd nil)
(nil? (asd nil))
(nil? nil=
)
(nil? nil)
(= 'nil 'nil)
(= 'nil 'NIL)
(type ())
(type (concat))
(igual? () ())
(igual? () 'nil)
(igual? () 'NIL)
(igual? () nil)
(igual? nil nil)
(igual? nil ())
(igual? nil 'nil)
(igual? nil 'NIL)
(igual? 'nil ())
(igual? () nil)
(igual? () ())
(igual? () 'nil)
(igual? () 'NIL)
(igual? 'nil nil)
(first (filter (fn [x] (not (igual? x nil))) '(nil nil 1 2)))
(first (filter (fn [x] (not (igual? x nil))) '(nil 'nil 1 2)))
exit
(first (filter (fn [x] (not (igual? x nil))) '(nil 'nil 1 2)))
(quote nil)
tp-formales.core=> exit
first (filter (fn [x] (not (igual? x nil))) '(nil 'nil 1 2)))
first (filter (fn [x] (not (igual? x nil))) '(nil 'nil 1 2))))
(first (filter (fn [x] (not (igual? x nil))) '(nil 'nil 1 2)))
(not (igual? nil nil))
(not (igual? 'nil nil))
(filter (fn [x] (not (igual? x nil))) '(nil 'nil 1 2))
(not (igual? x nil))
(not (igual? nil nil))
(not (igual? 1 nil))
(not (igual? 'nil nil))
(not (igual? (quote nil) nil))
(not (igual? 1 nil))
(not (igual? 'NIL nil))
(filter (fn [x] (not (igual? x nil))) '(nil 'NIL 1 2))
(filter (fn [x] (not (igual? x nil))) '(nil 1 2))
(filter (fn [x] (not (igual? x nil))) '(nil nil 1 2))
(defn take-first-not-null [l]
  (not (igual? (first l) nil)) (first l)
  (empty? l) nil
  :else (take-first-not-null (rest l)))
(take-first-not-null '(1 2))
(empty? 1
)
(empty? 1
(take-first-not-null '(1 2))
))
(take-first-not-null '(1 2))
(not (igual? (first '(1 2)) nil))
(take-first-not-null '(1 2))
(exit)
(take-first-not-null '(1 2))
(take-first-not-null '('NIL 1 2))
(igual? '('NIL 1 2) nil)
(igual? (first '('NIL 1 2)) nil)
(igual? (first '('nil 1 2)) nil)
(first '('NIL 1 2))
(igual? (quote NIL) nil)
(igual? '(quote NIL) nil)
(igual? (quote NIL) nil)
(map igual? '('nil 1 2))
(map (fn[x] (igual? x nil)) '('nil 1 2))
(map (fn[x] (igual? nil x)) '('nil 1 2))
(igual? nil 'nil)
(map list '('nil 1 2))
(igual? (quote nil) nil)
(map list '((quote nil) 1 2))
(map (fn[x] (igual? nil x)) '((quote nil) 1 2))
(map (fn[x] (if (igual? nil x) nil x) '((quote nil) 1 2))
)
(map (fn[x] (if (igual? nil x) nil x) '((quote nil) 1 2)))
(map (fn[x] (if (igual? nil x) nil x)) '((quote nil) 1 2)))
(map (fn[x] (if (igual? nil x) nil x)) '((quote nil) 1 2))
(defn esNil?[x] (igual? nil x))
(map esNil? '('nil 1 2))
(map esNil? '(nil 1 2))
(cons nil '(1 2 3))
(empty? (())
)
(empty? (()))
(empty? '(()))
(igual? nil (first '(())))
(cons 'a nil))
(cons 'a nil)
(concat 'a '(1 2 3))
(concat '(a) '(1 2 3))
(cons 'a ())
(list 'a ())
(list 'a nil)
(type (map #(+ %1 1) '(1 2 3))
)
(type (map #(+ %1 1) '(1 2 3))
)
(seq? nil)
exit
(list-to-lowercase '(nil NIL))
(list-to-lowercase '(1 a A))
(seq? nil)
(seq? ())
exit
(str nil)
(empty? (str nil))
(str 1)
(empty? (str '(1 2 3))
)
(empty? (str '(1 2 3)))
(= "nil" "nil)
)
"
)
(= "nil" "nil")
(str nil)
(str ())
(= "" (str nil))
(seq? "123))
)
2
df
f
exi
exit
(igual? nil 'NIL)
(second '(1)) 
(evaluar (equal 1 2))
(empty? (nil))
(empty? '(nil))
(empty? (rest '(nil))
)
(type (reverse '(1 2)))
